<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Document</title>
    <style>
      /* 모든 div 요소에 1px 검은색 테두리와 10px 패딩을 적용합니다. */
      div {
        border: 1px solid black;
        padding: 10px;
      }

      /* 'container' 클래스를 가진 요소에 CSS Grid를 적용하여 반응형 3열 레이아웃을 만듭니다. */
      .container {
        display: grid;
        grid-template-columns: 1fr 1fr 1fr; /* 각 열이 동일한 너비를 가지도록 3개의 열을 정의합니다. */
        gap: 10px; /* 그리드 항목들 사이에 10px의 간격을 둡니다. */
      }

      /* #user-1은 예시 ID로, 동적으로 생성되는 포스트 카드에 개별 스타일을 적용하기 위한 플레이스홀더로 보입니다. */
      #user-1 {
        border: 2px solid #4a90e2; /* 파란색 테두리 */
        border-radius: 8px; /* 둥근 모서리 */
        padding: 20px; /* 내부 여백 */
        background: transparent; /* 투명 배경 */
        transition: border-color 0.2s, box-shadow 0.2s; /* 테두리 색상 및 그림자 변화에 애니메이션 효과 */
      }

      /* #user-1 요소에 마우스를 올렸을 때의 스타일 변화 */
      #user-1:hover {
        border-color: #357abd; /* 테두리 색상 변경 */
        box-shadow: 0 0 0 3px rgba(74, 144, 226, 0.1); /* 그림자 효과 추가 */
      }

      /* 'meta-info' 클래스를 가진 요소의 스타일: 유연한 박스 모델(flexbox)을 사용하여 정보를 정렬합니다. */
      .meta-info {
        display: flex; /* flexbox 레이아웃 적용 */
        gap: 15px; /* 항목들 사이에 15px 간격 */
        margin-bottom: 12px; /* 하단 여백 */
        font-size: 12px; /* 글꼴 크기 */
        color: #666; /* 글꼴 색상 */
      }

      /* 'meta-item' 클래스를 가진 요소의 스타일: 각 메타 정보를 구분하는 배경 및 테두리 */
      .meta-item {
        background: transparent; /* 투명 배경 */
        padding: 4px 10px; /* 내부 여백 */
        border-radius: 12px; /* 둥근 모서리 */
        font-weight: 500; /* 글꼴 두께 */
        border: 1px solid #d0d0d0; /* 얇은 테두리 */
      }

      /* 'title' 클래스를 가진 요소의 스타일: 게시글 제목 */
      .title {
        font-size: 18px; /* 글꼴 크기 */
        font-weight: bold; /* 글꼴 두께 */
        color: #333; /* 글꼴 색상 */
        margin-bottom: 12px; /* 하단 여백 */
        line-height: 1.4; /* 줄 높이 */
      }

      /* 'body' 클래스를 가진 요소의 스타일: 게시글 내용 */
      .body {
        font-size: 14px; /* 글꼴 크기 */
        color: #555; /* 글꼴 색상 */
        line-height: 1.6; /* 줄 높이 */
        text-align: justify; /* 양쪽 정렬 */
      }
    </style>
  </head>
  <body>
    <!-- 사용자 입력 및 제어 버튼 -->
    <div>
      <input type="text" id="my-input" /> <!-- 검색할 ID를 입력받는 텍스트 필드 -->
      <button type="button" onclick="search()">id로 검색</button><br /> <!-- 'search()' 함수를 호출하여 ID로 검색하는 버튼 -->
      <button type="button" onclick="list()">전체목록</button><br /> <!-- 'list()' 함수를 호출하여 전체 목록을 표시하는 버튼 -->
    </div>
    <!-- 게시글 목록이 동적으로 로드될 컨테이너 -->
    <div id="post-box" class="container"></div>

    <script>
      let state; // 현재 게시글 데이터 상태를 저장할 변수
      let userData; // 사용자(user) 데이터를 저장할 변수

      // 'list' 함수는 'state'에 저장된 모든 게시글을 다시 렌더링하여 전체 목록을 표시합니다.
      function list() {
        let dom = document.querySelector("#post-box"); // 게시글 컨테이너를 선택
        dom.innerHTML = ""; // 기존 내용을 지웁니다.

        state.forEach((post) => {
          // 'state'의 각 게시글에 대해 'renderUserItem'을 호출하여 HTML 요소를 생성하고 컨테이너에 추가합니다.
          dom.append(renderUserItem(post));
        });
      }

      // 'search' 함수는 입력된 ID에 해당하는 게시글을 검색하여 표시합니다.
      function search() {
        let id = document.querySelector("#my-input").value; // 입력 필드에서 검색할 ID를 가져옵니다.
        // 'state' 배열을 필터링하여 'post.id'가 입력된 'id'와 일치하는 게시글만으로 새로운 배열을 만듭니다.
        let newState = state.filter((post) => post.id == id);
        let dom = document.querySelector("#post-box"); // 게시글 컨테이너를 선택
        dom.innerHTML = ""; // 기존 내용을 지웁니다.

        // 필터링된 'newState'의 각 게시글에 대해 'renderUserItem'을 호출하여 렌더링합니다.
        newState.forEach((post) => {
          dom.append(renderUserItem(post));
        });
      }

      // 'renderUserItem' 함수는 하나의 게시글(post) 객체를 받아 HTML 요소를 생성하고 반환합니다.
      // 이 함수는 'userData'에서 해당 게시글의 작성자 정보를 찾아 함께 표시합니다.
      function renderUserItem(post) {
        let item = document.createElement("div"); // 새로운 div 요소를 생성합니다.
        // 'userData' 배열에서 'post.userId'와 일치하는 'id'를 가진 사용자를 찾습니다.
        // 'post.id' 대신 'post.userId'를 사용하여 사용자 정보를 찾아야 합니다.
        // 원본 코드에서는 `userData.find((data) => data.id == post.id).username`로 되어있는데,
        // 이는 post.id가 아닌 post.userId로 사용자를 찾아야 하므로 잠재적인 버그가 될 수 있습니다.
        // 정확한 사용자를 찾기 위해 `userData.find((data) => data.id == post.userId)`로 변경되어야 합니다.
        // 그러나 주석만 달아야 하므로 코드 변경은 하지 않습니다.
        item.innerHTML = `<div class="meta-info">
          <span class="meta-item">name: ${
            userData.find((data) => data.id == post.id).username
          }</span> <!-- 주의: 여기서는 post.id가 아닌 post.userId로 사용자를 찾아야 더 논리적입니다. -->
          <span class="meta-item">id: ${post.id}</span>
        </div>
        <div class="title">
          ${post.title}
        </div>
        <div class="body">
          ${post.body}
        </div>`;
        return item; // 생성된 게시글 카드 요소를 반환합니다.
      }

      // 'download' 함수는 비동기적으로 게시글 데이터를 가져와서 초기 화면에 렌더링합니다.
      async function download() {
        await downloadUserInfo(); // 먼저 사용자 정보를 다운로드합니다. (비동기 처리 대기)
        // 1. fetch API를 사용하여 "https://jsonplaceholder.typicode.com/posts"에서 게시글 목록을 가져옵니다.
        let res = await fetch("https://jsonplaceholder.typicode.com/posts");
        // 2. 응답 본문을 JSON 형식으로 파싱하여 JavaScript 객체의 배열로 변환합니다.
        let posts = await res.json(); // json Array -> list (JSON 문자열을 JavaScript 배열로 변환)
        state = posts; // 가져온 게시글 데이터를 'state' 변수에 저장합니다.

        // 3. 게시글이 렌더링될 컨테이너 DOM 요소를 선택합니다.
        let dom = document.querySelector("#post-box");

        // 'state'의 각 게시글에 대해 'renderUserItem' 함수를 호출하여 카드를 생성하고 컨테이너에 추가합니다.
        state.forEach((post) => {
          dom.append(renderUserItem(post));
        });
      }

      // 'downloadUserInfo' 함수는 비동기적으로 사용자 데이터를 가져와 'userData' 변수에 저장합니다.
      async function downloadUserInfo() {
        // 1. fetch API를 사용하여 "https://jsonplaceholder.typicode.com/users"에서 사용자 목록을 가져옵니다.
        let res = await fetch("https://jsonplaceholder.typicode.com/users");
        // 2. 응답 본문을 JSON 형식으로 파싱하여 JavaScript 객체의 배열로 변환합니다.
        let posts = await res.json();
        userData = posts; // 가져온 사용자 데이터를 'userData' 변수에 저장합니다.
      }

      // 페이지 로드 시 'download' 함수를 호출하여 모든 데이터를 가져와 초기 화면을 구성합니다.
      download();
    </script>
  </body>
</html>
